<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3688 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3688.xml">
<!ENTITY rfc6020 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6020.xml">
<!ENTITY rfc7950 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7950.xml">
]>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-anima-voucher-latest">
    <front>
        <title abbrev="Voucher Profile">Voucher Profile for Bootstrapping Protocols</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
          <organization>Sandelman Software</organization>
          <address>
            <email>mcr+ietf@sandelman.ca</email>
            <uri>http://www.sandelman.ca/</uri>
          </address>
        </author>
        <author initials="M.P." surname="Pritikin" fullname="Max Pritikin">
            <organization>Cisco Systems</organization>
            <address>
                <email>pritikin@cisco.com</email>
            </address>
        </author>
        <author initials="T.E." surname="Eckert" fullname="Toerless Eckert">
            <address>
                <email>tte+anima@cs.fau.de</email>
            </address>
        </author>

        <date/>
        <area>Operations</area>
        <workgroup>ANIMA Working Group</workgroup>
        <keyword>voucher</keyword>
        <abstract>
            <t>This document defines the "voucher" artifact,
            which is a YANG-defined structure that have been signed using a PKCS#7 
            structure.</t>

            <t>The voucher artifact is generated by the device's manufacture or delegate
            (i.e. the MASA).  The voucher's purpose is to securely assign one or more
            pledges to an owner.  The voucher informs each pledge which entity it should
            consider to be its owner.</t>

            <t>This document only defines the artifact, leaving it
            to future work to describe specialized protocols for accessing them.</t>
        </abstract>
    </front>

    <middle>
      <section title="Introduction" anchor="introduction">

        <t>This document defines a strategy to securely assign pledges to an owner, using
        an artifact signed, directly or indirectly, by the device's manufacturer.
        This artifact is known as the voucher.</t>

        <t>A voucher may be useful in several contexts, but the driving
        motivation herein is to support secure bootstrapping mechanisms. This
        document only defines the voucher artifact, leaving it to other work
        to describe specialized protocols for accessing and distributing them
        (e.g., <xref target="draft-ietf-netconf-zerotouch"/>,
        <xref target="I-D.ietf-6tisch-dtsecurity-secure-join"/>, and
        <xref target="draft-ietf-anima-bootstrapping-keyinfra"/>).  Assigning
        ownership is important to bootstrapping mechanisms so that the pledge
        can authenticate the network that's trying to take control of it.</t>

        <t>The lifetimes of vouchers may vary.  In some bootstrapping protocols
        the vouchers may be ephemeral, whereas in others the vouchers may be
        potentially long-lived.  In order to support the second category of vouchers,
        this document recommends using short-life vouchers with programatic 
        renewal, enabling the MASA to communicate the ongoing validity of vouchers.</t>

        <t>This document uses YANG <xref target="RFC7950"/> to define the voucher
        format.  YANG is a data modeling language with
        established mappings to XML and JSON, with mappings to other encodings
        in progress.  This document has selected JSON for document encodings.</t>
        
        <section title="Terminology">
            <t>This document uses <xref target="draft-ietf-anima-bootstrapping-keyinfra"/> 
            terminology. The new device is known as a "Pledge", which communicates with 
            the "Join Registrar" of the owner's network, and the voucher is provided by the
            Manufacturer Authorized Signing Authority (MASA).</t> 
        </section>

        <section title="Requirements Language">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
                and "OPTIONAL" in the sections below are to be interpreted
                as described in RFC 2119 <xref target="RFC2119"/>.</t>
        </section>

        <section title="Tree Diagram Notation" anchor="tree-diagram">
          <t>The meaning of the symbols used in the tree-diagrams for YANG
             modules is as follows:</t>
          <t><list style="symbols">
            <t>Brackets "[" and "]" enclose list keys.</t>
            <t>Braces "{" and "}" enclose feature names, and indicate
               that the named feature must be present for the subtree
               to be present.</t>
            <t>Abbreviations before data node names: "rw" (read-write)
               represents configuration data and "ro" (read-only)
               represents state data.</t>
            <t>Symbols after data node names: "?" means an optional
               node, "!" means a presence container, and "*" denotes a
               list and leaf-list.</t>
            <t>Parentheses enclose choice and case nodes, and case
               nodes are also marked with a colon (":").</t>
            <t>Ellipsis ("...") stands for contents of subtrees that
               are not shown.</t>
          </list></t>
        </section>

        <section title="Secure Imprinting using Vouchers">
            <t>A voucher is a cryptographically protected statement to the Pledge
                device indicating authorizing a zero-touch "imprint" on the Join Registrar of the 
                domain. The voucher imparts the following information to
                the Join Registrar and Pledge:</t>
            
            <t><list style="hanging">
                <t hangText="Assertion Basis:">Indicates the method that protects
                    the imprint (this is distinct from the voucher signature that 
                    protects the voucher itself). This might include manufacturer 
                    asserted ownership verification, assured logging operations or 
                    reliance on Pledge endpoint behavior such as secure root of trust 
                    of measurement. The Join Registrar might use this information. 
                    Only some methods are normatively defined in this 
                    document. Other methods are left for future work.</t>
                
                <t hangText="Authentication of Join Registrar:">Indicates how the Pledge
                    can authenticate the Join Registrar. This might include an indication
                    of the private PKIX trust anchor used by the Registrar, or an indication
                    of a public PKIX trust anchor and additional CN-ID or DNS-ID
                    information to complete authentication. Symmetric key or other
                    methods are left for future work.</t>

                <t hangText="Anti-Replay Protections:">Time or nonce based
                    information to constrain the voucher to time periods or bootstrap
                    attempts.</t>
            </list></t>

            <t>A number of boostrapping scenarios can be met using differing
                combinations of this information. All scenarios address the primary
                threat of a Man-in-The-Middle Registrar gaining control over the Pledge device. The
                following combinations are referred to within this document by
                name. Colloqually these are "types" of vouchers:</t>

            <figure>
                <artwork><![CDATA[
             |Assertion   |Registrar ID    | Validity    |
Voucher      |Log-|Veri-  |Trust  |CN-ID or| RTC | Nonce |
Name         | ged|  fied |Anchor |DNS-ID  |     |       |
---------------------------------------------------------|
Audit        |  X |       | X     |        |     | X     |
-------------|----|-------|-------|--------|-----|-------|
Nonceless    |  X |       | X     |        | X   |       |
Audit        |    |       |       |        |     |       |
-------------|----|-------|-------|--------|-----|-------|
Owner Audit  |  X |   X   | X     |        | X   | X     |
-------------|----|-------|-------|--------|-----|-------|
Owner ID     |    |   X   | X     |  X     | X   |       |
-------------|----|-------|----------------|-----|-------|
Bearer       |  X |       |   wildcard     | optional    |
-------------|----|-------|----------------|-------------|

  NOTE: All voucher types include a 'Pledge ID serial number'
        (Not shown for space reasons)
                ]]></artwork>
            </figure>

            <t><list style="hanging">
                <t hangText="Audit Voucher:">An Audit Voucher is named after the
                    logging assertion mechanisms that the Registrar then "audits" to
                    enforce local policy. The Registrar mitigates a MiTM Registrar by
                    auditing that an unknown MiTM registrar does not appear in the log
                    entries. This does not direct prevent the MiTM but provides a
                    response mechanism that ensures the MiTM is unsuccessful. This
                    advantage is that actual ownership knowledge is not required on
                    the MASA service.</t>

                <t hangText="Nonceless Audit Voucher:">An Audit Voucher without a
                    validity period statement. Fundamentally the same as an Audit
                    Voucher except that it can be issued in advance to support network
                    partitions or to provide a permanent voucher for remote
                    deployments.</t>

                <t hangText="Ownership Audit Voucher:">An Audit Voucher where the
                    MASA service has verified the Registrar as the authorized owner.
                    The MASA service mitigates a MiTM Registrar by refusing to
                    generate Audit Voucher's for unauthorized Registrars. The
                    Registrar uses audit techniques to supplement the MASA. This
                    provides an ideal sharing of policy decisions and enforcement
                    between the vendor and the owner.</t>

                <t hangText="Ownership ID Voucher:">An Ownership ID Voucher is
                    named after inclusion of the Pledge's CN-ID or DNS-ID within the
                    voucher. An example Ownership Voucher is defined in <xref target="draft-ietf-netconf-zerotouch"/>. The MASA service
                    mitigates a MiTM Registrar by identifying the specific Registrar
                    authorized to own the Pledge.</t>

                <t hangText="Bearer Voucher:">A Bearer Voucher is named after the
                    inclusion of a Registrar ID wildcard. Because the Registrar identity
                    is not indicated this voucher type must be treated as a
                    secret and protected from exposure as any 'bearer' of the voucher
                    can claim the Pledge device. Publishing a nonceless
                    bearer voucher effectively turns the specified Pledge into a
                    "TOFU" device with minimal mitigation against MiTM Registrars.</t>
            </list></t> 
        </section> <!-- end Imprint using Voucher -->
      </section>  <!-- end Introduction -->

      <section title="Voucher" anchor="voucher">

        <t>The voucher's purpose is to securely assign one or more pledges 
        to an owner.  The voucher informs each pledge which entity it should
        consider to be its owner.</t>
  
        <t>The voucher is signed by the pledge's MASA, using the signing
        strategy described in Section <xref target="signing-strategy"/>.  
        This section describes the voucher document, before it has been signed.</t>

        <section title="Tree Diagram" anchor="voucher-tree-diagram">
          <t>The following tree diagram (<xref target="tree-diagram"/>)
          illustrates a high-level view of a voucher document.  Each field
          in the voucher is fully described by the YANG module provided in
          <xref target="voucher-yang-module"/>.  Please see
          <xref target="voucher-yang-module"/> for a detailed description
          of the Voucher format.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-voucher-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Examples" anchor="voucher-examples">
          <t>This section provides a couple Voucher examples for illustration
             purposes.</t>

          <t>The following example illustrates an ephemeral voucher (uses a nonce)
             encoded in JSON.  As is expected with a dynamically-generated voucher,
             only a single pledge (device-identifier) is specified.  The MASA 
             generated this voucher using the 'logged' assertion type, knowing
             that it would be suitable for the pledge making the request.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-ephemeral.json)
]]></artwork>
          </figure>

          <t>The following illustrates a long-lived voucher (no nonce), encoded in XML.
             This particular voucher applies to more than one pledge (unique-id), which
             might relate to, for instance, they were all issued as part of the same
             purchase order.  This voucher includes both a trust anchor
             certificate (trusted-ca-certificate) as well as some additional information
             (cn-id and dns-id) that can be used to identify a specific domain certificate
             issued, perhaps indirectly, by the trust anchor CA.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-long-lived.json)
]]></artwork>
          </figure>

        </section>  <!-- examples -->

        <section title="YANG Module" anchor="voucher-yang-module">

          <figure>
            <artwork><![CDATA[
<CODE BEGINS> file "ietf-voucher@YYYY-MM-DD.yang"

INSERT_TEXT_FROM_FILE(ietf-voucher@YYYY-MM-DD.yang)

<CODE ENDS>

]]></artwork>
          </figure>

        </section>  <!-- yang module -->

      </section>  <!-- voucher -->


      <section title="Voucher Revocation" anchor="voucher-revocation">

        <t>A revocation artifact is generally used to verify the continued validity
            of an assertion such as a PKIX certificate, web token, or a 
            "voucher". Conceptually revocation allows for issuance of 
            assertions using long lifetimes and thereby avoiding ongoing 
            protocol operations to renew the assertion. In practice the use of
            revocation artifacts increases the solution complexity. Rather than a 
            single protocol, or operation, to obtain or renew the assertion 
            the resulting solution instead has two or more protocols: one for 
            assertion maintenence and the other(s) for revocation verification.</t>
        
        <t>The PKIX use of CRLs and OCSP responses provides an illustrative
            example. Relying parties that verify revocation information must
            obtain and parse the CRL or OCSCP information. Each revocation method has
            its own validity period that effectively shortens the certificate
            validity period (since without valid revocation checks the 
            certificate would be rejected). In addition to having multiple
            revocation protocol options the resulting space is further 
            complicated by inline distribution of the revocation information. The
            TLS extension "Certificate Status Request" [RFC6066] for when 
            "constrained clients may wish to use a certificate-status protocol"
            is an example of this. Including revocation information into
            Cryptographic Message Syntax [RFC5652] is another example.</t>
        
        <t>If vouchers included revocation similar complexities would propagate
            to all related voucher distribution and assertion protocols. Instead
            vouchers do not support revocation. Instead of the
            asserting party, or relying party, obtaining and distributing
            revocation information the asserting party
            MUST obtain an up-to-date valid voucher. The protocol and operations
            infrastructures for this are expected to be the same as the 
            initial methods used to obtain a voucher in the first place, with
            one important clarification: the MASA services MUST issue updated
            validity period vouchers to the same Registrar ID with minimal 
            friction. This is similar to how an OCSP revocation system is 
            always willing to confirm that a certificate is not revoked. There is 
            no requirement implied that vouchers be contigiously renewed. For example
            if a two-week lifetime voucher is not used before it expires there is 
            no requirement that it be still valid when renewed. The domain MAY
            renew an expired voucher at any time. The MASA always has 
            authoritative control and MAY reject such renewals (such as when 
            requested by domain owner's to "block" renewals or if the device
            has been successfully claimed by an alternate domain). Allowing
            non-contigous lifetimes significantly reduces the operational load on 
            the domain as it is not required to maintain valid vouchers; only to ensure
            a valid voucher is available during the time window in which it
            needs to be used.</t>
        
        <t> [[EDNOTE: It might be worth including an indication
            of maxium lifetime for which such automated renewal is available. If so
            the language we'd use would be similar to the RFC5280 statement that
            certificate validity period is "the time interval during which the
            CA warrents that it will maintain information about the status of
            the certificate" only here used to inform the Registrar of "the time
            interval during which the MASA warrents that it will maintain information
            about the status of the ownership claim". Such a field would be independent of the
            actual validity period of the voucher and is not intended for
            consumption by the Pledge. A suggested name for this field would
            be "last-renewal-date".]]</t>
        
        <t>The communications to the MASA service regarding claiming and blocking
            of devices is out of scope of this specification. Similarly if 
            revocation methods had been described the method of reporting
            a revocation would have been out-of-scope.</t> 
        
        <t>The lifetimes of vouchers
            may vary.  In some bootstrapping protocols the vouchers may be ephemeral,
            whereas in others the vouchers may be potentially long-lived.  For
            bootstrapping protocols that support ephemeral vouchers, there is no
            need to support renewal.  For bootstrapping protocols that support
            long-lived vouchers final protocol complexity is reduced when short
            lifetime vouchers are easily renewed rather than layering on 
            additional revocation methods. Manufacturers MAY issue long-lived
            vouchers to customers if required but no revocation method is described.</t>

      </section>  <!-- voucher revocation -->

      <section title="Signing Strategy" anchor="signing-strategy">
        <t>The Voucher is signed using a PKCS#7
        SignedData structure, as specified by Section 9.1 of RFC 2315, having
        the 'content' be JSON-encoded data conforming to the YANG modules
        described in section <xref target="voucher"/>.</t>
        <t>The Voucher PKCS#7 structures MAY
        contain additional structures deemed useful.  For instance the
        Voucher structure MAY also contain all of the certificates leading 
        up to and including a root-level trust anchor certificate.</t>
        <t>If the Registrar Identity is compromised then any outstanding
            voucher for that Registrar Identity could be used by the 
            attacker. The domain administrator is clearly expected to
        initiate revocation of any domain identity certificates (as in
        normal in PKI solutions). Similarly
        they are expected to contact the MASA to 
        indicate that an outstanding (presumably short lifetime) voucher
        be blocked from automated renewal. Protocols for voucher distribution
        are RECOMMENDED to check for revocation of any domain identity 
        certificates before automated renewal of vouchers.</t>
      </section>
<!--
      <section title="CWT representation of ownership voucher" anchor="cwtvoucher">
        <t>
          This section details to use of <xref target="I-D.ietf-ace-cbor-web-token" />
          as the on-wire format for the vouchers.
        </t>
        <t>
          <xref target="I-D.ietf-ace-cbor-web-token" /> creates a series of
          standard claims. They are replicated from
          <xref target="RFC7519"/>.
          The set is intended to be customized, users of CWT are expected
          to define which ones are required or optional. (Section 3.1 of <xref
          target="I-D.ietf-ace-cbor-web-token" />).  They include: iss
          (Issuer), sub (Subject), aud (Audience), exp (Expiration Time), nbf
        (Not Before), iat (Issued At), and cti (CWT ID). </t> 

        <t>
          For ease of reading, this is not in the JWT canonical format.
          <figure>
            <artwork><![CDATA[
            INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-jwt.json)
            ]]></artwork>
          </figure>
        </t>
        
        <t>
          <list style="symbols">
            <t>The Issuer claim maps directly for the manufacturer.</t>
            <t>The Subject claim to be the device to which the voucher
            applies.</t>
            <t>The Audience claim designtates the Domain and/or Registrar which is to owner
            the device</t>
            <t>The Expiration Time is probably not used, but could be in some
            situations.</t>
            <t>The Not Before claim is the inception date of the
            voucher. Time may be unavailable to the pledge to validate it,
            but it may be ignored.</t>
            <t>The Issued at claim is the time the voucher has been created.
            This will not generally be much before Issued at, but could be.
            The pledge may also assume that the token would not be issued
            prior to the Issued At time, and so assume that real time is not
            before that time for the purpose of setting it's clock.</t>
            <t>The CWT ID may be assumed to be the Nonce.</t>
            <t>The Logged attribute would represent if the voucher includes
            a promise to audit the result.</t>
          </list>
        </t>
        
        <t>
          TBD: a fully base64 example of the CWT encoded.
        </t>
      </section>
-->

      <section title="Design Considerations" anchor="design-con">
        <section title="Voucher Per Pledge">
          <t>The solution originally enabled a single voucher to apply
          to many pledges, using lists of regular expressions to represent
          device identifiers.  However, when thinking about blocking renewal
          of vouchers, it was decided that blocking such a voucher would be excessive
          when only the ownership of a single pledge needed to be blocked.</t>
        </section> 
      </section>

      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity">
          <t>This document defines artifacts containing time values
          for voucher expirations, which
          require an accurate clock in order to be processed
          correctly.  Vendors planning on issuing vouchers with
          time values MUST ensure devices have an accurate clock when
          shipped from manufacturing facilities,
          and take steps to prevent clock tampering.</t>

        <t>If it is not possible to ensure clock accuracy then
            nonce based validity period vouchers SHOULD be used. 
            When necessary nonce-less, or long validity vouchers,
            can be issued with the understanding that there is no
            revocation method available (if a revocation method
            was possible then shorter lifetime vouchers would also
            have been an option).</t>

          <t>It is important to note that implementations SHOULD NOT
          rely on NTP for time, as it is not a secure protocol.</t>
        </section>
      </section>

      <section title="IANA Considerations" anchor="iana-considerations">

        <section title="The IETF XML Registry">
          <t>This document registers a URIs in the IETF XML
          registry <xref target="RFC3688"/>.  Following the format in
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-voucher
   Registrant Contact: The ANIMA WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="The YANG Module Names Registry">
          <t>This document registers a YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.
          Following the format defined in <xref target="RFC6020"/>, the
          the following registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-voucher
   namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher
   prefix:       vch
   reference:    RFC XXXX
]]></artwork>
          </figure>
        </t>
        </section>
      </section>

      <section title="Acknowledgements">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name):
        </t>
      </section>

    </middle>

    <back>
        <references title="Normative References">
            &rfc2119;
            &rfc6020;
            &rfc7950;
        </references>

        <references title="Informative References">
            &rfc3688;

            <?rfc include="reference.I-D.ietf-ace-cbor-web-token" ?>
            <?rfc include="reference.RFC.7519.xml" ?>
           <?rfc include="reference.I-D.ietf-6tisch-dtsecurity-secure-join" ?>

          <reference anchor='draft-ietf-netconf-zerotouch' target="https://tools.ietf.org/html/draft-ietf-netconf-zerotouch">
            <front>
              <title>Zero Touch Provisioning for NETCONF or RESTCONF based Management</title>
              <author initials='K.W.' surname='Watsen' fullname='Kent Watsen'>
                <organization>Cisco</organization>
              </author>
              <author initials='M.A.' surname='Abrahamsson' fullname='Mikael Abrahamsson'>
                <organization>T-Systems</organization>
              </author>
              <date year='2016' />
            </front>
            <seriesInfo name='Internet-Draft' value='draft-ietf-netconf-zerotouch'/>
          </reference>
          <reference anchor='draft-ietf-anima-bootstrapping-keyinfra' target="https://tools.ietf.org/html/draft-ietf-anima-bootstrapping-keyinfra">
            <front>
              <title>Bootstrapping Key Infrastructures</title>
              <author initials='M.P.' surname='Pritikin' fullname='Max Pritikin'>
                <organization>Cisco</organization>
              </author>
              <author initials='M.R.' surname='Richardson' fullname='Micheal Richardson'>
                <organization>Sandelman Software Works</organization>
              </author>
              <author initials='M.B.' surname='Behringer' fullname='Micheal Behringer'>
                <organization>Cisco</organization>
              </author>
              <author initials='S.B.' surname='Bjarnason' fullname='Steinthor Bjarnason'>
                <organization>Cisco</organization>
              </author>
              <date year='2016' />
            </front>
            <seriesInfo name='Internet-Draft' value='draft-ietf-anima-bootstrapping-keyinfra'/>
          </reference>
        </references>

        <section title="Change Log">
        </section>
    </back>
</rfc>

