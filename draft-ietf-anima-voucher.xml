<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-anima-voucher-latest">
    <front>
        <title abbrev="Voucher Profile">Voucher Profile for Bootstrapping Protocols</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
          <organization>Sandelman Software</organization>
          <address>
            <email>mcr+ietf@sandelman.ca</email>
            <uri>http://www.sandelman.ca/</uri>
          </address>
        </author>
        <author initials="M.P." surname="Pritikin" fullname="Max Pritikin">
            <organization>Cisco Systems</organization>
            <address>
                <email>pritikin@cisco.com</email>
            </address>
        </author>
        <author initials="T.E." surname="Eckert" fullname="Toerless Eckert">
            <address>
                <email>tte+anima@cs.fau.de</email>
            </address>
        </author>

        <date/>
        <area>Operations</area>
        <workgroup>ANIMA Working Group</workgroup>
        <keyword>voucher</keyword>
        <abstract>
          <t>This document defines a strategy to securely assign a pledge to an owner,
          using an artifact signed, directly or indirectly, by the pledge's manufacturer.
          This artifact is known as a "voucher".</t>

          <t>The voucher artifact is a YANG-defined JSON document that has been
          signed using a PKCS#7 structure.  The voucher artifact is generated by
          the pledge's manufacture or delegate (i.e. the MASA).</t>

          <t>This document only defines the voucher artifact, leaving it to other
          documents to describe specialized protocols for accessing it.</t>
        </abstract>
    </front>

    <middle>
      <section title="Introduction" anchor="introduction">

        <t>This document defines a strategy to securely assign a pledge to an owner,
        using an artifact signed, directly or indirectly, by the pledge's manufacturer
        or delegate (i.e. the MASA).  This artifact is known as the voucher.</t>

        <t>The voucher artifact is a JSON document, conforming to a data model
        described by YANG <xref target="RFC7950"/>,  that has been signed using
        a PKCS#7 structure.</t>

        <t>A voucher may be useful in several contexts, but the driving motivation
        herein is to support secure bootstrapping mechanisms.  Assigning
        ownership is important to bootstrapping mechanisms so that the pledge
        can authenticate the network that's trying to take control of it.</t>

        <t>The lifetimes of vouchers may vary.  In some bootstrapping protocols
        the vouchers may be ephemeral, whereas in others the vouchers may be
        potentially long-lived.  In order to support the second category of vouchers,
        this document recommends using short-life vouchers with programatic 
        renewal, enabling the MASA to communicate the ongoing validity of vouchers.</t>

        <t>This document only defines the voucher artifact, leaving it to other
        documents to describe specialized protocols for accessing it.  Some bootstrapping
        protocols using the voucher artifact defined in this draft include:
        <xref target="I-D.ietf-netconf-zerotouch"/>,
        <xref target="I-D.ietf-6tisch-dtsecurity-secure-join"/>, and
        <xref target="I-D.ietf-anima-bootstrapping-keyinfra"/>).</t>
      </section>

      <section title="Terminology">

        <t>The following terms are defined for clarity:</t>
<!--
          <t>This document uses <xref target="draft-ietf-anima-bootstrapping-keyinfra"/> 
          terminology. The new device is known as a "Pledge", which communicates with 
          the "Join Registrar" of the owner's network, and the voucher is provided by the
          Manufacturer Authorized Signing Authority (MASA).</t> 
 
    Terminology that is used in this document include:
        imprint
        pledge
        voucher
        domain
        domain CA / certificate (kinda)
        registrar
        MASA
        TOFU
-->
        <t><list style="hanging">

        <t hangText="Imprint:">The process where a device obtains the
            cryptographic key material to identify and trust future
            interactions with a network. This term is taken from Konrad
            Lorenz's work in biology with new ducklings: during a critical
            period, the duckling would assume that anything that looks like a
            mother duck is in fact their mother. An equivalent for a device is
            to obtain the fingerprint of the network's root certification
            authority certificate. A device that imprints on an attacker
            suffers a similar fate to a duckling that imprints on a hungry
            wolf. Securely imprinting is a primary focus of this
            document.<xref target="imprinting"></xref>. The analogy to
            Lorenz's work was first noted in <xref
                target="Stajano99theresurrecting"></xref>.</t>

        <t hangText="Pledge:">The prospective device attempting
            to find and join a secure remote key infrastructure. When
        shipped it only trusts authorized representatives of the 
        manufacturer.</t>

        <t hangText="Voucher:">A signed statement from the MASA service
            that indicates to a Pledge the cryptographic identity of the
            Registrar it should trust. There are different types of vouchers
            depending on how that trust asserted. This document
            describes vouchers in detail.</t>
        
        <t hangText="Domain:">The set of entities that trust a common key
            infrastructure trust anchor. This includes the Proxy, Registrar,
            Domain Certificate Authority, Management components and any
            existing entity that is already a member of the domain.</t>
        
        <t hangText="Domain CA:">The domain Certification Authority (CA)
            provides certification functionalities to the domain. At a minimum
            it provides certification functionalities to a Registrar and
            stores the trust anchor that defines the domain. Optionally, it
            certifies all elements.</t>
        
        <t hangText="Join Registrar (and Coordinator):">A representative of the domain that is
            configured, perhaps autonomically, to decide whether a new device
            is allowed to join the domain. The administrator of the domain
            interfaces with a Join Registrar (and Coordinator) to control this process. Typically a
            Join Registrar is "inside" its domain. For simplicity this document
            often refers to this as just "Registrar". The term JRC is used in
            common with other bootstrap mechanisms.</t>

        <t hangText="MASA Service:">A third-party Manufacturer Authorized
            Signing Authority (MASA) service on the global Internet. The MASA
            signs vouchers. It also provides a repository for audit log
            information of privacy protected bootstrapping events. It does
            not track ownership. It is trusted by the Pledge.</t>

        <t hangText="TOFU:">Trust on First Use. Used similarly to <xref
            target="RFC7435" />. This is where a Pledge
            device makes no security decisions but rather simply trusts the
            first Registrar it is contacted by. This is also known as the
            "resurrecting duckling" model.</t>
        </list></t> 
      </section>

      <section title="Requirements Language">
          <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
              "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
              and "OPTIONAL" in the sections below are to be interpreted
              as described in RFC 2119 <xref target="RFC2119"/>.</t>
      </section>

      <section title="Survey of Voucher Types">

          <t>A voucher is a cryptographically protected statement to the Pledge
              device authorizing a zero-touch "imprint" on the Join Registrar of the 
              domain. The specific information a voucher provides is influenced by the 
              bootstrapping use case.</t>
              
              <t>The voucher can impart the following information to
              the Join Registrar and Pledge:</t>
          
          <t><list style="hanging">
              <t hangText="Assertion Basis:">Indicates the method that protects
                  the imprint (this is distinct from the voucher signature that 
                  protects the voucher itself). This might include manufacturer 
                  asserted ownership verification, assured logging operations or 
                  reliance on Pledge endpoint behavior such as secure root of trust 
                  of measurement. The Join Registrar might use this information. 
                  Only some methods are normatively defined in this 
                  document. Other methods are left for future work.</t>
              
              <t hangText="Authentication of Join Registrar:">Indicates how the Pledge
                  can authenticate the Join Registrar. This might include an indication
                  of the private PKIX trust anchor used by the Registrar, or an indication
                  of a public PKIX trust anchor and additional CN-ID or DNS-ID
                  information to complete authentication. Symmetric key or other
                  methods are left for future work.</t>

              <t hangText="Anti-Replay Protections:">Time or nonce based
                  information to constrain the voucher to time periods or bootstrap
                  attempts.</t>
          </list></t>

          <t>A number of bootstrapping scenarios can be met using differing
              combinations of this information. All scenarios address the primary
              threat of a Man-in-The-Middle Registrar gaining control over the Pledge device. The
              following combinations are "types" of vouchers:</t>

          <figure>
              <artwork><![CDATA[
             |Assertion   |Registrar ID    | Validity    |
Voucher      |Log-|Veri-  |Trust  |CN-ID or| RTC | Nonce |
Name         | ged|  fied |Anchor |DNS-ID  |     |       |
---------------------------------------------------------|
Audit        |  X |       | X     |        |     | X     |
-------------|----|-------|-------|--------|-----|-------|
Nonceless    |  X |       | X     |        | X   |       |
Audit        |    |       |       |        |     |       |
-------------|----|-------|-------|--------|-----|-------|
Owner Audit  |  X |   X   | X     |        | X   | X     |
-------------|----|-------|-------|--------|-----|-------|
Owner ID     |    |   X   | X     |  X     | X   |       |
-------------|----|-------|----------------|-----|-------|
Bearer       |  X |       |   wildcard     | optional    |
out-of-scope |    |       |                |             |
-------------|----|-------|----------------|-------------|

NOTE: All voucher types include a 'Pledge ID serial number'
      (Not shown for space reasons)
              ]]></artwork>
          </figure>

          <t><list style="hanging">
              <t hangText="Audit Voucher:">An Audit Voucher is named after the
                  logging assertion mechanisms that the Registrar then "audits" to
                  enforce local policy. The Registrar mitigates a MiTM Registrar by
                  auditing that an unknown MiTM registrar does not appear in the log
                  entries. This does not direct prevent the MiTM but provides a
                  response mechanism that ensures the MiTM is unsuccessful. This
                  advantage is that actual ownership knowledge is not required on
                  the MASA service.</t>

              <t hangText="Nonceless Audit Voucher:">An Audit Voucher without a
                  validity period statement. Fundamentally the same as an Audit
                  Voucher except that it can be issued in advance to support network
                  partitions or to provide a permanent voucher for remote
                  deployments.</t>

              <t hangText="Ownership Audit Voucher:">An Audit Voucher where the
                  MASA service has verified the Registrar as the authorized owner.
                  The MASA service mitigates a MiTM Registrar by refusing to
                  generate Audit Voucher's for unauthorized Registrars. The
                  Registrar uses audit techniques to supplement the MASA. This
                  provides an ideal sharing of policy decisions and enforcement
                  between the vendor and the owner.</t>

              <t hangText="Ownership ID Voucher:">An Ownership ID Voucher is
                  named after inclusion of the Pledge's CN-ID or DNS-ID within the
                  voucher. An example Ownership Voucher is defined in 
                  <xref target="I-D.ietf-netconf-zerotouch"/>. The MASA service
                  mitigates a MiTM Registrar by identifying the specific Registrar
                  authorized to own the Pledge. [DISCUSS: still needed?]</t>

              <t hangText="Bearer Voucher:">A Bearer Voucher is named after the
                  inclusion of a Registrar ID wildcard. Because the Registrar identity
                  is not indicated this voucher type must be treated as a
                  secret and protected from exposure as any 'bearer' of the voucher
                  can claim the Pledge device. Publishing a nonceless
                  bearer voucher effectively turns the specified Pledge into a
                  "TOFU" device with minimal mitigation against MiTM Registrars. Bearer
                  vouchers are out-of-scope.</t>
          </list></t> 
      </section> <!-- end Imprint using Voucher -->

      <section title="Voucher" anchor="voucher">

        <t>The voucher's purpose is to securely assign a pledge to an owner.
        The voucher informs the pledge which entity it should consider to be
        its owner.</t>

        <t>The voucher is signed a PKCS#7 SignedData structure, as specified
        by Section 9.1 of <xref target="RFC2315"/>, encoded using ASN.1
        distinguished encoding rules (DER), as specified in ITU-T X.690.</t>

        <t>The PKCS#7 structure MUST contain JSON-encoded content conforming
        to the YANG module specified in <xref target="voucher-yang-module"/>.</t>

        <t>The PKCS#7 structure MUST also contain a 'signerInfo' structure, as
        described in Section 9.1 of <xref target="RFC2315"/>, containing the
        signature generated over the content using the MASA's private key.</t>

        <t>The PKCS#7 structure SHOULD also contain all of the certificates 
        leading up to and including the MASA's trust anchor certificate
        known to the pledges.</t>

        <section title="Tree Diagram" anchor="voucher-tree-diagram">
          <t>The following tree diagram <xref target="I-D.bjorklund-netmod-yang-tree-diagrams"/>
          illustrates a high-level view of a voucher document.  Each field
          in the voucher is fully described by the YANG module provided in
          <xref target="voucher-yang-module"/>.  Please review this YANG
          module for a detailed description of the voucher format.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-voucher-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Examples" anchor="voucher-examples">
          <t>This section provides a couple Voucher examples for illustration
             purposes.</t>

          <t>The following example illustrates an ephemeral voucher (uses a nonce)
             encoded in JSON.  As is expected with a dynamically-generated voucher,
             only a single pledge (device-identifier) is specified.  The MASA 
             generated this voucher using the 'logged' assertion type, knowing
             that it would be suitable for the pledge making the request.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-ephemeral.json)
]]></artwork>
          </figure>

          <t>The following illustrates a long-lived voucher (no nonce), encoded in XML.
             This particular voucher applies to more than one pledge (unique-id), which
             might relate to, for instance, they were all issued as part of the same
             purchase order.  This voucher includes both a trust anchor
             certificate (trusted-ca-certificate) as well as some additional information
             (cn-id and dns-id) that can be used to identify a specific domain certificate
             issued, perhaps indirectly, by the trust anchor CA.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-long-lived.json)
]]></artwork>
          </figure>

        </section>  <!-- examples -->

        <section title="YANG Module" anchor="voucher-yang-module">

          <figure>
            <artwork><![CDATA[
<CODE BEGINS> file "ietf-voucher@YYYY-MM-DD.yang"

INSERT_TEXT_FROM_FILE(ietf-voucher@YYYY-MM-DD.yang)

<CODE ENDS>

]]></artwork>
          </figure>
        </section>  <!-- yang module -->

      </section>  <!-- voucher -->


      <section title="Design Considerations" anchor="design-con">

        <section title="Renewals instead of Revocations" anchor="renewal-over-revocation">

          <t>A revocation artifact is generally used to verify the continued validity
          of an assertion such as a PKIX certificate, web token, or a 
          "voucher". Conceptually revocation allows for issuance of 
          assertions using long lifetimes and thereby avoiding ongoing 
          protocol operations to renew the assertion. In practice the use of
          revocation artifacts increases the solution complexity. Rather than a 
          single protocol, or operation, to obtain or renew the assertion 
          the resulting solution instead has two or more protocols: one for 
          assertion maintanence and the other(s) for revocation verification.</t>
          
          <t>The PKIX use of CRLs and OCSP responses provides an illustrative
          example. Relying parties that verify revocation information must
          obtain and parse the CRL or OCSP information. Each revocation method has
          its own validity period that effectively shortens the certificate
          validity period (since without valid revocation checks the 
          certificate would be rejected). In addition to having multiple
          revocation protocol options the resulting space is further 
          complicated by inline distribution of the revocation information. The
          TLS extension "Certificate Status Request" [RFC6066] for when 
          "constrained clients may wish to use a certificate-status protocol"
          is an example of this. Including revocation information into
          Cryptographic Message Syntax [RFC5652] is another example.</t>
          
          <t>If vouchers included revocation similar complexities would propagate
          to all related voucher distribution and assertion protocols. Instead
          vouchers do not support revocation. Instead of the
          asserting party, or relying party, obtaining and distributing
          revocation information the asserting party
          MUST obtain an up-to-date valid voucher. The protocol and operations
          infrastructures for this are expected to be the same as the 
          initial methods used to obtain a voucher in the first place, with
          one important clarification: the MASA services MUST issue updated
          validity period vouchers to the same Registrar ID with minimal 
          friction. This is similar to how an OCSP revocation system is 
          always willing to confirm that a certificate is not revoked. There is 
          no requirement implied that vouchers be contiguously renewed. For example
          if a two-week lifetime voucher is not used before it expires there is 
          no requirement that it be still valid when renewed. The domain MAY
          renew an expired voucher at any time. The MASA always has 
          authoritative control and MAY reject such renewals (such as when 
          requested by domain owner's to "block" renewals or if the device
          has been successfully claimed by an alternate domain). Allowing
          non-contiguous lifetimes significantly reduces the operational load on 
          the domain as it is not required to maintain valid vouchers; only to ensure
          a valid voucher is available during the time window in which it
          needs to be used.</t>
          
          <t> [[EDNOTE: It might be worth including an indication
          of maximum lifetime for which such automated renewal is available. If so
          the language we'd use would be similar to the RFC5280 statement that
          certificate validity period is "the time interval during which the
          CA warrants that it will maintain information about the status of
          the certificate" only here used to inform the Registrar of "the time
          interval during which the MASA warrants that it will maintain information
          about the status of the ownership claim". Such a field would be independent of the
          actual validity period of the voucher and is not intended for
          consumption by the Pledge. A suggested name for this field would
          be "last-renewal-date".]]</t>
          
          <t>The communications to the MASA service regarding claiming and blocking
          of devices is out of scope of this specification. Similarly if 
          revocation methods had been described, the method of reporting
          a revocation would have been out-of-scope.</t> 
          
          <t>The lifetimes of vouchers
          may vary.  In some bootstrapping protocols the vouchers may be ephemeral,
          whereas in others the vouchers may be potentially long-lived.  For
          bootstrapping protocols that support ephemeral vouchers, there is no
          need to support renewal.  For bootstrapping protocols that support
          long-lived vouchers, final protocol complexity is reduced when short
          lifetime vouchers are easily renewed rather than layering on 
          additional revocation methods. Manufacturers MAY issue long-lived
          vouchers to customers if required but no revocation method is described.</t>
        </section>

        <section title="Voucher Per Pledge">
          <t>The solution originally enabled a single voucher to apply
          to many pledges, using lists of regular expressions to represent
          ranges of serial numbers.  However, it was determined that
          blocking the renewal of a voucher that applied to many devices,
          would be excessive when only the ownership for a single pledge
          needed to be blocked.</t>
        </section> 
      </section>

      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity">
          <t>This document defines artifacts containing time values
          for voucher expirations, which require an accurate clock
          in order to be processed correctly.  Vendors planning on
          issuing vouchers with expiration values MUST ensure devices
          have an accurate clock when shipped from manufacturing
          facilities, and take steps to prevent clock tampering.
          If it is not possible to ensure clock accuracy then
          vouchers with expirations SHOULD NOT be issued.</t>
        </section>
        <section title="Protect Voucher PKI in HSM">
          <t>This document favors using voucher-renewals over needing to
          support voucher-revocations (<xref target="renewal-over-revocation"/>).
          However, a voucher may be signed by a chain of intermediate CAs
          leading to the trust anchor known to a pledge.  Without revocation
          checking, it means that there will also not be any revocation
          checking for any of the CA certificates in the chain.  This leads
          to scenario whereby a stolen intermediate private key results in
          the ability for the embezzler to issue vouchers as infinitum without
          recourse.  For this reason, implementations SHOULD ensure that
          all the CA private keys are protected by hardware security modules
          (HSMs).</t> 
        </section>
        <section title="Test Certificate Validity when Signing">
          <t>If the Registrar Identity is compromised then any outstanding
              voucher for that Registrar Identity could be used by the 
              attacker. The domain administrator is clearly expected to
          initiate revocation of any domain identity certificates (as in
          normal in PKI solutions). Similarly
          they are expected to contact the MASA to 
          indicate that an outstanding (presumably short lifetime) voucher
          be blocked from automated renewal. Protocols for voucher distribution
          are RECOMMENDED to check for revocation of any domain identity 
          certificates before automated renewal of vouchers.</t>
        </section>
      </section>

      <section title="IANA Considerations" anchor="iana-considerations">

        <section title="The IETF XML Registry">
          <t>This document registers a URIs in the IETF XML
          registry <xref target="RFC3688"/>.  Following the format in
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-voucher
   Registrant Contact: The ANIMA WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="The YANG Module Names Registry">
          <t>This document registers a YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.
          Following the format defined in <xref target="RFC6020"/>, the
          the following registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-voucher
   namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher
   prefix:       vch
   reference:    RFC XXXX
]]></artwork>
          </figure>
        </t>
        </section>
      </section>


    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.2315.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.7950.xml"?>
      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.I-D.ietf-netconf-zerotouch" ?>
        <?rfc include="reference.I-D.ietf-anima-bootstrapping-keyinfra" ?>
        <?rfc include="reference.I-D.ietf-6tisch-dtsecurity-secure-join" ?>
        <?rfc include="reference.RFC.7435" ?>

        <reference anchor="I-D.bjorklund-netmod-yang-tree-diagrams">
          <front>
            <title>YANG Tree Diagrams</title>
            <author initials='M.B.' surname='Bjorklund' fullname='Martin Bjorklund'>
              <organization>Tail-f Systems</organization>
            </author>
            <author initials='L.B.' surname='Berger' fullname='Lou Berger'>
              <organization>LABN</organization>
            </author>
            <date year='2017' />
          </front>
        </reference>
        
        <reference anchor="Stajano99theresurrecting"
            target="https://www.cl.cam.ac.uk/~fms27/papers/1999-StajanoAnd-duckling.pdf">
            <front>
                <title>The resurrecting duckling: security issues for ad-hoc
                    wireless networks</title>
                
                <author fullname="Frank Stajano" initials="F." surname="Stajano"></author>
                
                <author fullname="Ross Anderson" initials="R." surname="Anderson"></author>
                
                <date year="1999" />
            </front>
        </reference>
        <reference anchor="imprinting"
            target="https://en.wikipedia.org/wiki/Imprinting_(psychology)">
            <front>
                <title>Wikipedia article: Imprinting</title>
                
                <author surname="Wikipedia"></author>
                
                <date month="July" year="2015" />
            </front>
        </reference>
        
      </references>
      <section title="Acknowledgements">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name):
        </t>
      </section>
    </back>
</rfc>

