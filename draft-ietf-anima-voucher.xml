<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-anima-voucher-latest">
    <front>
        <title abbrev="Voucher Profile">Voucher Profile for Bootstrapping Protocols</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
          <organization>Sandelman Software</organization>
          <address>
            <email>mcr+ietf@sandelman.ca</email>
            <uri>http://www.sandelman.ca/</uri>
          </address>
        </author>
        <author initials="M.P." surname="Pritikin" fullname="Max Pritikin">
            <organization>Cisco Systems</organization>
            <address>
                <email>pritikin@cisco.com</email>
            </address>
        </author>
        <author initials="T.E." surname="Eckert" fullname="Toerless Eckert">
            <address>
                <email>tte+anima@cs.fau.de</email>
            </address>
        </author>

        <date/>
        <area>Operations</area>
        <workgroup>ANIMA Working Group</workgroup>
        <keyword>voucher</keyword>
        <abstract>
          <t>This document defines a strategy to securely assign a pledge to an owner,
          using an artifact signed, directly or indirectly, by the pledge's manufacturer.
          This artifact is known as a "voucher".</t>

          <t>The voucher artifact is a YANG-defined JSON document that has been
          signed using a PKCS#7 structure.  The voucher artifact is generated by
          the pledge's manufacture or delegate (i.e. the MASA).</t>

          <t>This document only defines the voucher artifact, leaving it to other
          documents to describe specialized protocols for accessing it.</t>
        </abstract>
    </front>

    <middle>
      <section title="Introduction" anchor="introduction">

        <t>This document defines a strategy to securely assign a pledge to an owner,
        using an artifact signed, directly or indirectly, by the pledge's manufacturer
        or delegate (i.e. the MASA).  This artifact is known as the voucher.</t>

        <t>The voucher artifact is a JSON document, conforming to a data model
        described by YANG <xref target="RFC7950"/>,  that has been signed using
        a PKCS#7 structure.</t>

        <t>A voucher may be useful in several contexts, but the driving motivation
        herein is to support secure bootstrapping mechanisms.  Assigning
        ownership is important to bootstrapping mechanisms so that the pledge
        can authenticate the network that's trying to take control of it.</t>

        <t>The lifetimes of vouchers may vary.  In some bootstrapping protocols
        the vouchers may be ephemeral, whereas in others the vouchers may be
        potentially long-lived.  In order to support the second category of vouchers,
        this document recommends using short-life vouchers with programatic 
        renewal, enabling the MASA to communicate the ongoing validity of vouchers.</t>

        <t>This document only defines the voucher artifact, leaving it to other
        documents to describe specialized protocols for accessing it.  Some bootstrapping
        protocols using the voucher artifact defined in this draft include:
        <xref target="I-D.ietf-netconf-zerotouch"/>,
        <xref target="I-D.ietf-6tisch-dtsecurity-secure-join"/>, and
        <xref target="I-D.ietf-anima-bootstrapping-keyinfra"/>).</t>
      </section>

      <section title="Terminology">

          <t>DISCUSS: MAX TO MOVE TERMS TO THIS DRAFT</t>
<!--
          <t>This document uses <xref target="draft-ietf-anima-bootstrapping-keyinfra"/> 
          terminology. The new device is known as a "Pledge", which communicates with 
          the "Join Registrar" of the owner's network, and the voucher is provided by the
          Manufacturer Authorized Signing Authority (MASA).</t> 
-->
      </section>

      <section title="Requirements Language">
          <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
              "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
              and "OPTIONAL" in the sections below are to be interpreted
              as described in RFC 2119 <xref target="RFC2119"/>.</t>
      </section>

      <section title="Secure Imprinting using Vouchers">

        <t>DISCUSS: do we need this section at all?  - or move to appendix?</t>

          <t>A voucher is a cryptographically protected statement to the Pledge
              device indicating authorizing a zero-touch "imprint" on the Join Registrar of the 
              domain. The voucher imparts the following information to
              the Join Registrar and Pledge:</t>
          
          <t><list style="hanging">
              <t hangText="Assertion Basis:">Indicates the method that protects
                  the imprint (this is distinct from the voucher signature that 
                  protects the voucher itself). This might include manufacturer 
                  asserted ownership verification, assured logging operations or 
                  reliance on Pledge endpoint behavior such as secure root of trust 
                  of measurement. The Join Registrar might use this information. 
                  Only some methods are normatively defined in this 
                  document. Other methods are left for future work.</t>
              
              <t hangText="Authentication of Join Registrar:">Indicates how the Pledge
                  can authenticate the Join Registrar. This might include an indication
                  of the private PKIX trust anchor used by the Registrar, or an indication
                  of a public PKIX trust anchor and additional CN-ID or DNS-ID
                  information to complete authentication. Symmetric key or other
                  methods are left for future work.</t>

              <t hangText="Anti-Replay Protections:">Time or nonce based
                  information to constrain the voucher to time periods or bootstrap
                  attempts.</t>
          </list></t>

          <t>A number of boostrapping scenarios can be met using differing
              combinations of this information. All scenarios address the primary
              threat of a Man-in-The-Middle Registrar gaining control over the Pledge device. The
              following combinations are referred to within this document by
              name. Colloqually these are "types" of vouchers:</t>

          <figure>
              <artwork><![CDATA[
             |Assertion   |Registrar ID    | Validity    |
Voucher      |Log-|Veri-  |Trust  |CN-ID or| RTC | Nonce |
Name         | ged|  fied |Anchor |DNS-ID  |     |       |
---------------------------------------------------------|
Audit        |  X |       | X     |        |     | X     |
-------------|----|-------|-------|--------|-----|-------|
Nonceless    |  X |       | X     |        | X   |       |
Audit        |    |       |       |        |     |       |
-------------|----|-------|-------|--------|-----|-------|
Owner Audit  |  X |   X   | X     |        | X   | X     |
-------------|----|-------|-------|--------|-----|-------|
Owner ID     |    |   X   | X     |  X     | X   |       |
-------------|----|-------|----------------|-----|-------|
Bearer       |  X |       |   wildcard     | optional    |
-------------|----|-------|----------------|-------------|

NOTE: All voucher types include a 'Pledge ID serial number'
      (Not shown for space reasons)
              ]]></artwork>
          </figure>

          <t><list style="hanging">
              <t hangText="Audit Voucher:">An Audit Voucher is named after the
                  logging assertion mechanisms that the Registrar then "audits" to
                  enforce local policy. The Registrar mitigates a MiTM Registrar by
                  auditing that an unknown MiTM registrar does not appear in the log
                  entries. This does not direct prevent the MiTM but provides a
                  response mechanism that ensures the MiTM is unsuccessful. This
                  advantage is that actual ownership knowledge is not required on
                  the MASA service.</t>

              <t hangText="Nonceless Audit Voucher:">An Audit Voucher without a
                  validity period statement. Fundamentally the same as an Audit
                  Voucher except that it can be issued in advance to support network
                  partitions or to provide a permanent voucher for remote
                  deployments.</t>

              <t hangText="Ownership Audit Voucher:">An Audit Voucher where the
                  MASA service has verified the Registrar as the authorized owner.
                  The MASA service mitigates a MiTM Registrar by refusing to
                  generate Audit Voucher's for unauthorized Registrars. The
                  Registrar uses audit techniques to supplement the MASA. This
                  provides an ideal sharing of policy decisions and enforcement
                  between the vendor and the owner.</t>

              <t hangText="Ownership ID Voucher:">An Ownership ID Voucher is
                  named after inclusion of the Pledge's CN-ID or DNS-ID within the
                  voucher. An example Ownership Voucher is defined in 
                  <xref target="I-D.ietf-netconf-zerotouch"/>. The MASA service
                  mitigates a MiTM Registrar by identifying the specific Registrar
                  authorized to own the Pledge. [DISCUSS: still needed?]</t>

              <t hangText="Bearer Voucher:">A Bearer Voucher is named after the
                  inclusion of a Registrar ID wildcard. Because the Registrar identity
                  is not indicated this voucher type must be treated as a
                  secret and protected from exposure as any 'bearer' of the voucher
                  can claim the Pledge device. Publishing a nonceless
                  bearer voucher effectively turns the specified Pledge into a
                  "TOFU" device with minimal mitigation against MiTM Registrars.</t>
          </list></t> 
      </section> <!-- end Imprint using Voucher -->

      <section title="Voucher" anchor="voucher">

        <t>The voucher's purpose is to securely assign a pledge to an owner.
        The voucher informs the pledge which entity it should consider to be
        its owner.</t>

        <t>The Voucher is signed a PKCS#7
        SignedData structure, as specified by Section 9.1 of RFC 2315, having
        the 'content' be JSON-encoded data conforming to the YANG modules
        described in section <xref target="voucher-yang-module"/>.</t>

        <t>The voucher's PKCS#7 structure MAY also contain additional
        structures deemed useful.  For instance the voucher's PKCS#7
        structure SHOULD contain all of the certificates leading up
        to and including a root-level trust anchor certificate.</t>

        <section title="Tree Diagram" anchor="voucher-tree-diagram">
          <t>The following tree diagram <xref target="I-D.bjorklund-netmod-yang-tree-diagrams"/>
          illustrates a high-level view of a voucher document.  Each field
          in the voucher is fully described by the YANG module provided in
          <xref target="voucher-yang-module"/>.  Please review this YANG
          module for a detailed description of the voucher format.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-voucher-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Examples" anchor="voucher-examples">
          <t>This section provides a couple Voucher examples for illustration
             purposes.</t>

          <t>The following example illustrates an ephemeral voucher (uses a nonce)
             encoded in JSON.  As is expected with a dynamically-generated voucher,
             only a single pledge (device-identifier) is specified.  The MASA 
             generated this voucher using the 'logged' assertion type, knowing
             that it would be suitable for the pledge making the request.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-ephemeral.json)
]]></artwork>
          </figure>

          <t>The following illustrates a long-lived voucher (no nonce), encoded in XML.
             This particular voucher applies to more than one pledge (unique-id), which
             might relate to, for instance, they were all issued as part of the same
             purchase order.  This voucher includes both a trust anchor
             certificate (trusted-ca-certificate) as well as some additional information
             (cn-id and dns-id) that can be used to identify a specific domain certificate
             issued, perhaps indirectly, by the trust anchor CA.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-long-lived.json)
]]></artwork>
          </figure>

        </section>  <!-- examples -->

        <section title="YANG Module" anchor="voucher-yang-module">

          <figure>
            <artwork><![CDATA[
<CODE BEGINS> file "ietf-voucher@YYYY-MM-DD.yang"

INSERT_TEXT_FROM_FILE(ietf-voucher@YYYY-MM-DD.yang)

<CODE ENDS>

]]></artwork>
          </figure>
        </section>  <!-- yang module -->

      </section>  <!-- voucher -->


      <section title="Design Considerations" anchor="design-con">

        <section title="Renewals instead of Revocations">

          <t>A revocation artifact is generally used to verify the continued validity
          of an assertion such as a PKIX certificate, web token, or a 
          "voucher". Conceptually revocation allows for issuance of 
          assertions using long lifetimes and thereby avoiding ongoing 
          protocol operations to renew the assertion. In practice the use of
          revocation artifacts increases the solution complexity. Rather than a 
          single protocol, or operation, to obtain or renew the assertion 
          the resulting solution instead has two or more protocols: one for 
          assertion maintanence and the other(s) for revocation verification.</t>
          
          <t>The PKIX use of CRLs and OCSP responses provides an illustrative
          example. Relying parties that verify revocation information must
          obtain and parse the CRL or OCSP information. Each revocation method has
          its own validity period that effectively shortens the certificate
          validity period (since without valid revocation checks the 
          certificate would be rejected). In addition to having multiple
          revocation protocol options the resulting space is further 
          complicated by inline distribution of the revocation information. The
          TLS extension "Certificate Status Request" [RFC6066] for when 
          "constrained clients may wish to use a certificate-status protocol"
          is an example of this. Including revocation information into
          Cryptographic Message Syntax [RFC5652] is another example.</t>
          
          <t>If vouchers included revocation similar complexities would propagate
          to all related voucher distribution and assertion protocols. Instead
          vouchers do not support revocation. Instead of the
          asserting party, or relying party, obtaining and distributing
          revocation information the asserting party
          MUST obtain an up-to-date valid voucher. The protocol and operations
          infrastructures for this are expected to be the same as the 
          initial methods used to obtain a voucher in the first place, with
          one important clarification: the MASA services MUST issue updated
          validity period vouchers to the same Registrar ID with minimal 
          friction. This is similar to how an OCSP revocation system is 
          always willing to confirm that a certificate is not revoked. There is 
          no requirement implied that vouchers be contiguously renewed. For example
          if a two-week lifetime voucher is not used before it expires there is 
          no requirement that it be still valid when renewed. The domain MAY
          renew an expired voucher at any time. The MASA always has 
          authoritative control and MAY reject such renewals (such as when 
          requested by domain owner's to "block" renewals or if the device
          has been successfully claimed by an alternate domain). Allowing
          non-contiguous lifetimes significantly reduces the operational load on 
          the domain as it is not required to maintain valid vouchers; only to ensure
          a valid voucher is available during the time window in which it
          needs to be used.</t>
          
          <t> [[EDNOTE: It might be worth including an indication
          of maximum lifetime for which such automated renewal is available. If so
          the language we'd use would be similar to the RFC5280 statement that
          certificate validity period is "the time interval during which the
          CA warrants that it will maintain information about the status of
          the certificate" only here used to inform the Registrar of "the time
          interval during which the MASA warrants that it will maintain information
          about the status of the ownership claim". Such a field would be independent of the
          actual validity period of the voucher and is not intended for
          consumption by the Pledge. A suggested name for this field would
          be "last-renewal-date".]]</t>
          
          <t>The communications to the MASA service regarding claiming and blocking
          of devices is out of scope of this specification. Similarly if 
          revocation methods had been described, the method of reporting
          a revocation would have been out-of-scope.</t> 
          
          <t>The lifetimes of vouchers
          may vary.  In some bootstrapping protocols the vouchers may be ephemeral,
          whereas in others the vouchers may be potentially long-lived.  For
          bootstrapping protocols that support ephemeral vouchers, there is no
          need to support renewal.  For bootstrapping protocols that support
          long-lived vouchers, final protocol complexity is reduced when short
          lifetime vouchers are easily renewed rather than layering on 
          additional revocation methods. Manufacturers MAY issue long-lived
          vouchers to customers if required but no revocation method is described.</t>
        </section>

        <section title="Voucher Per Pledge">
          <t>The solution originally enabled a single voucher to apply
          to many pledges, using lists of regular expressions to represent
          ranges of serial numbers.  However, it was determined that
          blocking the renewal of a voucher that applied to many devices,
          would be excessive when only the ownership for a single pledge
          needed to be blocked.</t>
        </section> 
      </section>

      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity">
          <t>This document defines artifacts containing time values
          for voucher expirations, which require an accurate clock
          in order to be processed correctly.  Vendors planning on
          issuing vouchers with expiration values MUST ensure devices
          have an accurate clock when shipped from manufacturing
          facilities, and take steps to prevent clock tampering.
          If it is not possible to ensure clock accuracy then
          vouchers with expirations SHOULD NOT be issued.</t>
        </section>
        <section title="Test Certificate Validity when Signing">
          <t>If the Registrar Identity is compromised then any outstanding
              voucher for that Registrar Identity could be used by the 
              attacker. The domain administrator is clearly expected to
          initiate revocation of any domain identity certificates (as in
          normal in PKI solutions). Similarly
          they are expected to contact the MASA to 
          indicate that an outstanding (presumably short lifetime) voucher
          be blocked from automated renewal. Protocols for voucher distribution
          are RECOMMENDED to check for revocation of any domain identity 
          certificates before automated renewal of vouchers.</t>
        </section>
      </section>

      <section title="IANA Considerations" anchor="iana-considerations">

        <section title="The IETF XML Registry">
          <t>This document registers a URIs in the IETF XML
          registry <xref target="RFC3688"/>.  Following the format in
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-voucher
   Registrant Contact: The ANIMA WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="The YANG Module Names Registry">
          <t>This document registers a YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.
          Following the format defined in <xref target="RFC6020"/>, the
          the following registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-voucher
   namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher
   prefix:       vch
   reference:    RFC XXXX
]]></artwork>
          </figure>
        </t>
        </section>
      </section>


    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.7950.xml"?>
      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.I-D.ietf-netconf-zerotouch" ?>
        <?rfc include="reference.I-D.ietf-anima-bootstrapping-keyinfra" ?>
        <?rfc include="reference.I-D.ietf-6tisch-dtsecurity-secure-join" ?>

        <reference anchor="I-D.bjorklund-netmod-yang-tree-diagrams">
          <front>
            <title>YANG Tree Diagrams</title>
            <author initials='M.B.' surname='Bjorklund' fullname='Martin Bjorklund'>
              <organization>Tail-f Systems</organization>
            </author>
            <author initials='L.B.' surname='Berger' fullname='Lou Berger'>
              <organization>LABN</organization>
            </author>
            <date year='2017' />
          </front>
        </reference>
      </references>
      <section title="Acknowledgements">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name):
        </t>
      </section>
    </back>
</rfc>

